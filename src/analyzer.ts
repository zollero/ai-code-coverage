import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import * as ignore from 'ignore';
import { AICodeAnalysis, AIPattern, ProjectAnalysis } from './types';

export class AICodeAnalyzer {
    private aiPatterns: { [key: string]: RegExp[] } = {
        // Common patterns of AI-generated code
        comments: [
            /\/\*\*[\s\S]*?Generated by.*?\*\//gi,
            /\/\/.*AI.*generated/gi,
            /\/\/.*Copilot/gi,
            /\/\/.*auto.*generated/gi,
            /\/\*.*Generated.*\*\//gi,
        ],
        
        structure: [
            // Highly regular function naming
            /function\s+[a-z]+\d+[A-Za-z]*\s*\(/g,
            // Excessive use of arrow functions
            /=>\s*{[\s\S]*?=>\s*{/g,
            // Unusually complex ternary expressions
            /\?\s*[^:]+\?\s*[^:]+:/g,
        ],
        
        naming: [
            // Very long variable names
            /\b[a-zA-Z][a-zA-Z0-9]{20,}\b/g,
            // Overly descriptive function names
            /function\s+[a-z][a-zA-Z0-9]*(?:And|Or|With|For|From|To|By)[A-Z]/g,
            // Repetitive variable name patterns
            /\b(temp|tmp|result|data|info|obj|item)\d+\b/g,
        ],
        
        complexity: [
            // Excessive type annotations
            /:\s*[A-Z][a-zA-Z0-9<>|&\[\]]*\s*=/g,
            // Very detailed try-catch blocks
            /try\s*{[\s\S]*?}\s*catch\s*\([^)]*\)\s*{[\s\S]*?console\.(log|error)/g,
        ]
    };

    private humanPatterns: RegExp[] = [
        // Characteristics of human-written code
        /\/\/\s*TODO:/gi,
        /\/\/\s*FIXME:/gi,
        /\/\/\s*HACK:/gi,
        /\/\/\s*NOTE:/gi,
        /console\.log\(/g,
        /debugger;/g,
    ];

    async analyzeFile(filePath: string): Promise<AICodeAnalysis> {
        try {
            const content = await fs.promises.readFile(filePath, 'utf-8');
            const lines = content.split('\n');
            
            const analysis: AICodeAnalysis = {
                filePath,
                totalLines: lines.length,
                aiGeneratedLines: 0,
                humanWrittenLines: 0,
                commentLines: 0,
                emptyLines: 0,
                aiPercentage: 0,
                humanPercentage: 0,
                confidence: 0,
                detectedPatterns: []
            };

            let aiScore = 0;
            let humanScore = 0;
            const detectedPatterns: AIPattern[] = [];

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                if (line === '') {
                    analysis.emptyLines++;
                    continue;
                }

                if (line.startsWith('//') || line.startsWith('/*') || line.startsWith('*')) {
                    analysis.commentLines++;
                }

                // Detect AI patterns
                for (const [type, patterns] of Object.entries(this.aiPatterns)) {
                    for (const pattern of patterns) {
                        const matches = line.match(pattern);
                        if (matches) {
                            aiScore += matches.length;
                            detectedPatterns.push({
                                type: type as any,
                                pattern: pattern.toString(),
                                confidence: 0.7,
                                description: this.getPatternDescription(type, pattern),
                                lineNumbers: [i + 1]
                            });
                        }
                    }
                }

                // Detect human patterns
                for (const pattern of this.humanPatterns) {
                    const matches = line.match(pattern);
                    if (matches) {
                        humanScore += matches.length * 2; // Human characteristics have higher weight
                    }
                }
            }

            // Calculate code lines (excluding empty lines and comments)
            const codeLines = analysis.totalLines - analysis.emptyLines - analysis.commentLines;
            
            // Calculate AI/human ratio based on scores
            const totalScore = aiScore + humanScore;
            if (totalScore > 0) {
                analysis.aiPercentage = Math.round((aiScore / totalScore) * 100);
                analysis.humanPercentage = 100 - analysis.aiPercentage;
            } else {
                // If no obvious characteristics, estimate based on code complexity
                analysis.aiPercentage = this.estimateByComplexity(content);
                analysis.humanPercentage = 100 - analysis.aiPercentage;
            }

            analysis.aiGeneratedLines = Math.round((analysis.aiPercentage / 100) * codeLines);
            analysis.humanWrittenLines = codeLines - analysis.aiGeneratedLines;
            analysis.confidence = Math.min(90, Math.max(10, totalScore * 10));
            analysis.detectedPatterns = detectedPatterns;

            return analysis;
        } catch (error) {
            throw new Error(`分析文件失败: ${error}`);
        }
    }

    async analyzeProject(projectPath: string): Promise<ProjectAnalysis> {
        const config = vscode.workspace.getConfiguration('aiCodeCoverage');
        const excludePatterns = config.get<string[]>('excludePatterns', []);
        
        const files = await this.getCodeFiles(projectPath, excludePatterns);
        const fileAnalyses: AICodeAnalysis[] = [];
        
        let totalLines = 0;
        let totalAILines = 0;
        let totalHumanLines = 0;

        for (const file of files) {
            try {
                const analysis = await this.analyzeFile(file);
                fileAnalyses.push(analysis);
                totalLines += analysis.totalLines;
                totalAILines += analysis.aiGeneratedLines;
                totalHumanLines += analysis.humanWrittenLines;
            } catch (error) {
                console.error(`跳过文件 ${file}: ${error}`);
            }
        }

        const overallAiPercentage = totalLines > 0 ? 
            Math.round((totalAILines / (totalAILines + totalHumanLines)) * 100) : 0;

        return {
            projectPath,
            totalFiles: files.length,
            analyzedFiles: fileAnalyses.length,
            totalLines,
            aiGeneratedLines: totalAILines,
            humanWrittenLines: totalHumanLines,
            overallAiPercentage,
            fileAnalyses,
            timestamp: new Date()
        };
    }

    private async getCodeFiles(dir: string, excludePatterns: string[]): Promise<string[]> {
        const files: string[] = [];
        const codeExtensions = ['.ts', '.js', '.tsx', '.jsx', '.py', '.java', '.cpp', '.c', '.cs', '.php', '.rb', '.go', '.rs'];
        
        // Read .gitignore file
        const ig = ignore.default();
        const gitignorePath = path.join(dir, '.gitignore');
        
        try {
            if (fs.existsSync(gitignorePath)) {
                const gitignoreContent = await fs.promises.readFile(gitignorePath, 'utf-8');
                ig.add(gitignoreContent);
                console.log('Loaded .gitignore rules');
                console.log('gitignore content:', gitignoreContent.split('\n').filter(line => line.trim() && !line.startsWith('#')));
            }
        } catch (error) {
            console.warn('Failed to read .gitignore file:', error);
        }

        // 添加默认的忽略规则
        const defaultIgnores = [
            'node_modules',
            '.git',
            '.vscode',
            'dist',
            'out',
            'build',
            '.next',
            '.nuxt',
            'coverage',
            '.nyc_output',
            '*.log',
            '.DS_Store',
            'Thumbs.db'
        ];
        ig.add(defaultIgnores);
        console.log('Added default ignore rules:', defaultIgnores);

        // Add user-configured exclude patterns
        if (excludePatterns && excludePatterns.length > 0) {
            // Convert glob patterns to ignore format
            const convertedPatterns = excludePatterns.map(pattern => 
                pattern.replace(/^\*\*\//, '').replace(/\/\*\*$/, '')
            );
            ig.add(convertedPatterns);
            console.log('Added user exclude patterns:', convertedPatterns);
        }
        
        // Manually check if a path should be ignored
        function shouldIgnore(relativePath: string, isDirectory: boolean): boolean {
            const normalizedPath = relativePath.replace(/\\/g, '/');
            
            // 直接检查路径
            if (ig.ignores(normalizedPath)) {
                return true;
            }
            
            // 如果是目录，同时检查带斜杠的版本
            if (isDirectory && ig.ignores(normalizedPath + '/')) {
                return true;
            }
            
            // 检查路径的各个部分
            const pathParts = normalizedPath.split('/');
            for (const part of pathParts) {
                if (ig.ignores(part)) {
                    return true;
                }
            }
            
            return false;
        }
        
        async function scan(currentDir: string) {
            const entries = await fs.promises.readdir(currentDir, { withFileTypes: true });
            
            for (const entry of entries) {
                const fullPath = path.join(currentDir, entry.name);
                const relativePath = path.relative(dir, fullPath);
                
                // Check if should be ignored
                if (shouldIgnore(relativePath, entry.isDirectory())) {
                    console.log(`Ignoring ${entry.isDirectory() ? 'directory' : 'file'}: ${relativePath}`);
                    continue;
                }

                if (entry.isDirectory()) {
                    await scan(fullPath);
                } else if (codeExtensions.some(ext => entry.name.endsWith(ext))) {
                    console.log(`Including file: ${relativePath}`);
                    files.push(fullPath);
                }
            }
        }
        
        console.log(`Starting directory scan: ${dir}`);
        await scan(dir);
        console.log(`Scan completed, found ${files.length} code files`);
        return files;
    }

    private estimateByComplexity(content: string): number {
        // Simple estimation based on code complexity
        const lines = content.split('\n').filter(line => line.trim() !== '');
        const avgLineLength = lines.reduce((sum, line) => sum + line.length, 0) / lines.length;
        
        // AI代码通常更规整，行长度更一致
        const lengthVariance = this.calculateVariance(lines.map(line => line.length));
        
        // 较低的方差可能表示AI生成
        if (lengthVariance < 100 && avgLineLength > 30) {
            return 60; // 可能是AI生成
        }
        
        return 30; // 更可能是人工编写
    }

    private calculateVariance(numbers: number[]): number {
        const mean = numbers.reduce((sum, num) => sum + num, 0) / numbers.length;
        const squaredDiffs = numbers.map(num => Math.pow(num - mean, 2));
        return squaredDiffs.reduce((sum, diff) => sum + diff, 0) / numbers.length;
    }

    private getPatternDescription(type: string, pattern: RegExp): string {
        const descriptions: { [key: string]: string } = {
            'comments': 'AI生成代码注释模式',
            'structure': '规则的代码结构模式',
            'naming': 'AI典型的命名模式',
            'complexity': '过度复杂的类型注解'
        };
        return descriptions[type] || '未知模式';
    }
}
